#ifdef GLSL
layout (local_size_x = __wg_sz__, local_size_y = 1, local_size_z = 1) in;
layout(set = 0, binding = 0) readonly buffer in_t{
  float in_buf[];
};
layout(set = 0, binding = 1) buffer out_t{
  float out_buf[];
};
layout(set = 0, binding = 2) buffer out_in_yx_t{
  float out_buf_in_yx[];
};
layout (set = 0, binding = 3) buffer POD
{
  uint32_t avg_pool;
  uint32_t emit_out_in_yx;
  int kern_sz;
  int stride;
  int in_pad;
};
void main ()
#else
CUCL_GLOBAL_KERNEL void %(rtc_func_name)( uint32_t const avg_pool, // CUCL IN :
                                          uint32_t const emit_out_in_yx, // CUCL IN :
                                          GASQ float const * const in_buf, // CUCL IN img:chan:y:x
                                          GASQ void const * const kern_sz, // CUCL REF y:x
                                          GASQ void const * const stride, // CUCL REF y:x
                                          GASQ void const * const in_pad, // CUCL REF y:x
					  GASQ float * const out_buf, // CUCL OUT img:chan:y:x
					  GASQ float * const out_buf_in_yx ) // CUCL OUT img:chan:y:x
// note: out_in_yx will be NULL+unused if emit_out_in_yx is 0; otherwise it will be non-null and used.
// note: emit_out_in_yx will only be non-zero when avg_pool==0, as it's not sensible otherwise
#endif
{
  // CUCL IX GLOB_ID_1D out_buf
  if( GLOB_ID_1D >= %(GLOB_ID_1D_dims_prod) ) { return; }
  float out_v = %(avg_pool) != 0 ? 0.0f : -FLT_MAX;
  int oyx = -1; // invalid value, will prevent propogation of this output's gradient (note: oyx used only for max pool)
  float avg_pool_sz = 0;
  // note: to match caffe, only non-padding pixels are considered for both average and max pooling. it is assumed that
  // no window lies totally inside padding; in that case, -FLT_MAX would be returned by max pooling, and NaN (div by 0)
  // would be returned by average pooling.
  for( int32_t kx = 0; kx != %(kern_sz_x_dim); ++kx ) {
    for( int32_t ky = 0; ky != %(kern_sz_y_dim); ++ky ) {
      const int in_y = INT_CAST(%(GLOB_ID_1D_y)*%(stride_y_dim)) + ky - %(in_pad_y_dim);
      const int in_x = INT_CAST(%(GLOB_ID_1D_x)*%(stride_x_dim)) + kx - %(in_pad_x_dim);
      if(in_y >= 0 && in_x >= 0 && in_x < %(in_buf_x_dim) && in_y < %(in_buf_y_dim) ) {
	const int32_t in_ix = INT_CAST(%(GLOB_ID_1D_img))*%(in_buf_img_stride) + INT_CAST(%(GLOB_ID_1D_chan))*%(in_buf_chan_stride) + 
	  in_y*%(in_buf_y_stride) + in_x*%(in_buf_x_stride);
	const float v = in_buf[in_ix];
	if( %(avg_pool) != 0 ) { 
	  out_v += v; 
	  avg_pool_sz += 1;
	} else if( v > out_v ) {
	  out_v = v;
	  if( %(emit_out_in_yx) != 0 ) { oyx = INT_CAST(in_y*%(in_buf_x_dim) + in_x); } // propogate to (only) this input
	}
      }
    }
  }
  if( %(avg_pool) != 0 ) { out_v /= avg_pool_sz; }
  out_buf[GLOB_ID_1D] = out_v;
  if( %(emit_out_in_yx) != 0 ) { out_buf_in_yx[GLOB_ID_1D] = oyx; }
}
